c++并不是一个带有一组守则的一体语言，它是由四个次语言（c，Object-Oriented C++,Template C++,STL)组成的联邦政府。

###### explicit 声明：

阻止他们被用来执行隐式类型转换，但仍被用来进行显式类型转换；



![image-20210729102318565](image\image-20210729102318565.png)

Widget w3=w1                                 //调用copy构造函数

pass-by-value（值传递）意味“调用copy构造函数”

以值传递用户自定义类型通常是bad idea。

![image-20210729103103409](image\image-20210729103103409.png)

一般而言，可以合理假设只有内置类型和STL的迭代器和函数对象可以用值传递。其他任何东西都尽量用const 引用传递。

![image-20210729114907499](image\image-20210729114907499.png)

 const std::vector<int>::iterator iter;//iter指向的值可以改变，iter不能改变

std::vector<int>::const_iterator iter;

const 函数（）//修饰的是返回值，表示返回的是指针所指向值是常量

int hanshu() const//只读函数，不允许修改其中的值

 

![image-20210729174216393](image\image-20210729174216393.png)

![image-20210729173724522](image\image-20210729173724522.png)

mutable（可变） int   //这样声明在const 函数中也可以被更改



![image-20210730093755219](image\image-20210730093755219.png)

![image-20210730093729535](image\image-20210730093729535.png)

为了避免需要记住成员变量合适必须在成员初值列中初始化，何时不需要，最简单的做法就是：总是使用成员初值列。



​		许多classs拥有多个构造函数，每个构造函数有自己的成员初值列。这种类又存在许多成员变量和基类。在这种情况下可以合理地在初值列中遗漏那些“赋值表现像初始化一样好”的成员变量，改用它们的赋值操作，并将那些赋值操作移往某个函数（通常是private)，供所有构造函数调用。这种做法在“成员变量的初值系由文件或数据库读入”时特别有用。然而，比起经由赋值操作完成的“伪初始化”( pseudo-initialization)，通过成员初值列(memberinitialization list）完成的“真正初始化”通常更加可取。

为避免阅读者看你的代码迷惑和出现错误（某些成员变量的初始化带有次序性，如数组在初始化时需要指定大小，因此代表大小的那个成员变量必须先初始化。），在初值列中条列各个成员时，最好总是以声明次序为次序。







