异常处理

```c++
try{
	//检查语句
	if(错误){
        throw 异常
    }
    catch（异常类型）{
        进行异常处理的语句1；
    }
}
```

##### 异常捕获链

1,异常抛出后程序执行将立即跳转至最近的try块的最后，按顺序匹配catch块并执行；
2,相应的catch块执行后异常被处理，程序继续执行；
3,若无匹配的catch块则继续跳转至下一个最近的try块进行处理；
4,若当前函数中异常未被处理，则退出该函数（stack unwinding），在其调用函数中进行处理；
5,递归以上步骤支持异常被处理；
6,若跳转至最顶层依然无匹配的catch块，则程序退出；

##### 优缺点

优点
隔离异常处理代码
异常无法被忽略
构造函数可以报错
缺点
写异常安全的代码并不简单
错误现场易丢失
性能损失（现代编译器可能问题不大）
编译出的二进制文件体积较大

### 类型转换

##### static_cast

1，基本数据类型间的转换

2，基类及子类间的转换

3，编译时进行类型检查

##### dynamic_cast

向下转换

​		基类指针转换为子类指针

​		主要用于多态场景

运行时类型检查

​		基类指针不指向子类对象时转为空指针

​		底层实现基于虚表指针，无虚函数类不能使用dynamic_cast

static_cast

​		也可以做向下转换

​		不具备运行时类型检查

​		存在风险

也可用于引用，和指针用法类似

##### reinterpret_cast 

​		不同类型指针之间，指针与整型间强转

​		编译器不对指向对象的类型做任何检查

​		谨慎使用

##### const_cast

​		const指针或引用转为非const

​		存在非法场景（未定义行为）

​		使用场景较少

#### 智能指针

##### unique_ptr<type>  p(new type)

有使用new【】和delete【】版本

比auto安全 --不允许长时间存在的p赋值给另一个

可以使用move函数p2=move（p1）

##### share_ptr<type> p

两个指针共同指向一个对象

引用计数，赋值时计数器加1，指针过期时计数器减1；减为零时delete。

##### #weak_ptr

weak_ptr是一种不控制所指向对象生存期的智能指针，它指向一个由shared_ptr管理的对象，将一个weak_ptr绑定到一个shared_ptr不会改变shared_ptr的引用计数。一旦最后一个指向对象的shared_ptr被销毁，对象就会被释放，即使有weak_ptr指向对象，对象还是会被释放。
weak_ptr的操作

由于对象可能不存在，我们不能使用weak_ptr直接访问对象，而必须调用lock，此函数检查weak_ptr指向的对象是否存在。如果存在，lock返回一个指向共享对象的shared_ptr,如果不存在，lock将返回一个空指针



##### 发现一个神奇的问题

###### 析构函数自动调用两次

查了一些资料，还不是很清楚，但是经过仔细分析后，发现原来是系统调用默认拷贝构造函数的结果。

在返回对象和按值传递参数时，要生成临时对象，生成临时对象要调用默认拷贝构造函数。

通过这个例子更让我加深了对Effective C++的理解。

只要类里有指针变量就得自己写拷贝构造函数和赋值函数，但是你确定用不着这些函数时，可以把这些函数做private声明而不去实现它，这就防止了会有人去调用它们，也防止了编译器去生成它们。

原文链接：https://blog.csdn.net/jia_xiaoxin/article/details/3330744